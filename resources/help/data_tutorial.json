{
	"tutorials": [
		{
			"header":"Tutorial 1: How to use the platform?",
			"content":"<p>The platform at AimsQuant is divided into two main sections, strategy editor (or the \"editor\") section and community section. In this tutorial, we will discuss the editor section of the platform. The editor section of the platform is divided into three major components</p><ol><li>Code Editor</li><li>Settings Panel</li><li>Toolbar</li></ol><p><br></p><h3><strong>Code Editor</strong></h3><p><br></p><p>In code editor, user can define backtest settings and write strategy logic. Every strategy is subdivided into two function:</p><p><br></p><p>a.&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">initialize()</code>: Used to define settings like universe, dates, commission model etc.</p><p>b.&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">ondata()</code>: Used to write strategy logic. This function is called every time stamp and re-evaluates the strategy logic</p><p><br></p><blockquote><strong style=\"color: rgb(0, 71, 178);\"><em>User must create the above two functions</em></strong></blockquote><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Initialize function to set basic strategy parameters\nfunction initialize(state)\n    setcash(100000)\n    setstartdate(\"2016-01-01\")\n    setenddate(\"2017-10-01\")\n    . \n    setcancelpolicy(\"EOD\")\n    .\n    .\n    setslippage((\"PerTrade\", 0.02))\nend\n\n#Strategy logic\nfunction ondata(data, state)\n  price_history = history([\"TCS\",\"WIPRO\"], \"Close\", :Day, 22)\n  log_returns = percentchange(price_history, :log)\n  total_return = basecall(log_returns, cumsum)[end]\n  \n  if total_return[\"TCS\"] &gt; total_return[\"WIPRO\"]\n    setholdingpct(total_return[\"WIPRO\"], 0.0)\n    setholdingpct(total_return[\"TCS\"], 1.0)\n  else\n    setholdingpct(total_return[\"TCS\"], 0.0)\n    setholdingpct(total_return[\"WIPRO\"], 1.0)\n  end\nend\n</pre><p><br></p><p>User can also create sub-functions to break-down strategy logic into easy to comprehend sections. For ex: the function that calculates returns based on price data can be taken out of the&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">ondata()</code>&nbsp;function.</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Strategy logic\nfunction ondata(data, state)\n  price_history = history([\"TCS\",\"WIPRO\"], \"Close\", :Day, 22)\n  total_return = calculate_totalreturn(price_history)\n  if total_return[\"TCS\"] &gt; total_return[\"WIPRO\"]\n      setholdingpct(total_return[\"WIPRO\"], 0.0)\n      setholdingpct(total_return[\"TCS\"], 1.0)\n  else\n      setholdingpct(total_return[\"TCS\"], 0.0)\n      setholdingpct(total_return[\"WIPRO\"], 1.0)\n  end\nend\n\n#Calculate total returns\nfunction calculate_totalreturn(price_history)\n  log_returns = percentchange(price_history, :log)\n  total_return = basecall(log_returns, cumsum)[end]\nend\n</pre><p><br></p><h3><strong>Settings Panel</strong></h3><p><br></p><p>To simplify the&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">initialize()</code>&nbsp;function and to avoid writing basic settings every time, user can use settings panel to set the backtest settings. Settings are divided into Basic and Advanced settings. Initial Cash, backtesting dates, universe selection can be done</p><p>All the backtest settings are listed in an easy to understand UI</p><p><br></p><p>User can create any combination of settings without writing any code in&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">initialize()</code></p><p><br></p><blockquote><strong style=\"background-color: rgb(240, 240, 240); color: rgb(0, 71, 178);\"><code>initialize()</code></strong><strong style=\"color: rgb(0, 71, 178);\">&nbsp;must always be defined. However, it can be left empty</strong></blockquote><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">function initialize(state)\nend\n</pre><p><br></p><blockquote><strong style=\"color: rgb(0, 71, 178);\">settings defined in&nbsp;</strong><strong style=\"color: rgb(0, 71, 178); background-color: rgb(240, 240, 240);\"><code>initialize()</code></strong><strong style=\"color: rgb(0, 71, 178);\">&nbsp;WILL override the settings selected in settings panel</strong></blockquote><p><br></p><p><br></p><h3><strong>Toolbar</strong></h3><p><br></p><p>In addition to starting a backtest, Toolbar is used to create new strategies, cloning existing strategy, saving a strategy and inspecting previously run backtests for a strategy.</p><p><br></p><blockquote><strong style=\"color: rgb(0, 71, 178);\">Strategy is saved every 5 seconds to avoid loss of work</strong></blockquote><p><br></p>"
		},
		{
			"header":"Tutorial 2: Understanding the sample strategy",
			"content":"<p>In this tutorial, we will create a sample strategy to test the platform, understand the flow of data and available functions in API. In this strategy, 100% of wealth is equally divided and invested in two stocks, TCS and WIPRO.</p><p><br></p><p>As mentioned in&nbsp;<strong>Tutorial&nbsp;#1,&nbsp;</strong>we need to define two functions for successful execution of a strategy/backtest.</p><p><br></p><p><strong><em>In the section below, we show the components of strategy/backtest initialization</em></strong></p><p><br></p><p><strong>Set Cash to 10,00,000</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Set initial cash\nsetcash(1000000.0)\n</pre><p><br></p><p><strong>Set Commission to zero (Brokerage or commission charged by the broker)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Set commission (no commission) \nsetcommission(Commission(CommissionModel(PerTrade), 0.0)\n</pre><p><br></p><p><strong>Set Slippage to zero (Slippage is difference in the execution price and the close price)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Set slippage (no slippage)\nsetslippage(Slippage(SlippageModel(Variable), 0.0)\n</pre><p><br></p><p><strong>Set universe to include two stocks (TCS and WIPRO)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Set universe (mandatory before placing any orders)\nsetuniverse([\"TCS\", \"WIPRO\"])\n</pre><p><br></p><p><strong><em>In this section, we define the components of strategy logic</em></strong></p><p><br></p><p><strong>Fetch universe</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Get Universe\nuniverse = getuniverse()\n</pre><p><br></p><p><strong>Set the holding in each stock (uniform portfolio)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Set the holding in all stock in universe to 1/total number of stocks [uniform portfolio]\nfor stock in universe\n  #Function is executed every Day/Week/Month based on rebalance frequency\n  setholdingpct(stock, 1.0/length(universe))\nend\n</pre><p><br></p><p><strong>Track the Portfolio value (Portfolio Value is plotted on the graph)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Track the portfolio value\ntrack(\"Portfoliovalue\", state.account.netvalue)\n</pre><p><br></p><p><strong>Log the Portfolio Value (Portfolio Value is printed in the log)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#User Logger to output information to console\nLogger.info(\"Portofolio value = $(state.account.netvalue)\")\n</pre><p><br></p><p>Here is the complete strategy</p><pre class=\"ql-syntax\" spellcheck=\"false\">#Sample strategy to invest 100% of wealth equally in two stocks\n#Every strategy requires two mandatory functions\n#1. initialize(): Function to initialize the settings and&nbsp;user defined parameters\n#2. ondata(): Function to define strategy logic&nbsp;\n\n#Initialize the strategy with various settings and/or parameters\nfunction initialize(state)\n\n  #Set initial cash\n  setcash(1000000.0)\n\n  #Set commission (no commission) \n  setcommission(Commission(CommissionModel(PerTrade), 0.0)\n\n  #Set slippage (no slippage)\n  setslippage(Slippage(SlippageModel(Variable), 0.0)\n\n  #Set universe (mandatory before placing any orders)\n  setuniverse([\"TCS\", \"WIPRO\"])\nend\n\n#Define strategy logic here\n#This function is called every DAY\nfunction ondata(data, state)\n\n  #Get Universe\n  universe = getuniverse()\n\n  #Set the holding in all stock in universe to 1/total number of stocks [uniform portfolio]\n  for stock in universe\n    #Function is executed every Day/Week/Month based on rebalance frequency\n    setholdingpct(stock, 1.0/length(universe))\n  end\n\n  #Track the portfolio value\n  track(\"Portfoliovalue\", state.account.netvalue)\n  \n  #User Logger to output information to console    \n  Logger.info(\"Portofolio value = $(state.account.netvalue)\")\nend\n</pre><p><br></p><blockquote><strong style=\"color: rgb(0, 71, 178);\">This is a sample strategy (only to be used for experiment and research purpose). It does NOT constitute an investment advice.</strong></blockquote><p><br></p>"
		},
		{
			"header":"Tutorial 3: Creating a simple stock reversal strategy based on absolute momentum",
			"content":"<p><strong><em>Stock Reversal strategy invests in recent poor performers. It is based on hypothesis that there is an over-reaction when a stock underperforms and hence the stock recovers after a short-term underperformance.</em></strong></p><p><br></p><p>In this strategy, we create a proxy for underperformance by calculating the 22 day returns of stocks. Subsequently, returns are sorted and 100% of wealth is uniformly distributed in least performing 5 stocks.</p><p><br></p><p>This strategy is applied only on NIFTY constituents as of 25/01/2017. Hence, it has some shortcomings like&nbsp;<strong><em>sample bias&nbsp;</em></strong>and<strong><em>&nbsp;survivorship bias.</em></strong></p><p><br></p><p>In&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">initialize()</code>, we set universe as NIFTY constituents</p><pre class=\"ql-syntax\" spellcheck=\"false\">##################\n# Basic stock reversal strategy&nbsp;\n# Rebalances portfolio every week&nbsp;\n# Invest in bottom (least performing) 5 stocks of NIFTY based on\n# last 22 days return\n##################\n# Initialize the strategy with various settings and/or parameters\nfunction initialize(state)\n  # NIFTY 50 stock universe as of 25/01/2017\n  # This universe has Survivorship bias\n  universe = [\"ACC\",\"ADANIPORTS\",\"AMBUJACEM\",\n  \"ASIANPAINT\",\"AUROPHARMA\",\"AXISBANK\",\"BAJAJ_AUTO\",\n  \"BANKBARODA\",\"BHEL\",\"BPCL\",    \"BHARTIARTL\",\"INFRATEL\",\n  \"BOSCHLTD\",\"CIPLA\",\"COALINDIA\",\"DRREDDY\",\"EICHERMOT\",\n  \"GAIL\",\"GRASIM\",\"HCLTECH\",\"HDFCBANK\",\"HEROMOTOCO\",\"HINDALCO\",\n  \"HINDUNILVR\",\"HDFC\",\"ITC\",\"ICICIBANK\",\"IDEA\",\n  \"INDUSINDBK\",\"INFY\",\"KOTAKBANK\",\"LT\",\"LUPIN\",\"M_M\",\n  \"MARUTI\",\"NTPC\",\"ONGC\",\"POWERGRID\",\"RELIANCE\",\"SBIN\",\n  \"SUNPHARMA\",\"TCS\",\"TATAMTRDVR\",\"TATAMOTORS\",\"TATAPOWER\",\n  \"TATASTEEL\",\"TECHM\",\"ULTRACEMCO\",\"WIPRO\",\"YESBANK\",\"ZEEL\"]\n\n  # Set universe (mandatory before placing any orders)\n    # Dynamic universe is not allowed yet\n    setuniverse(universe)\nend\n</pre><p><br></p><p>In&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">ondata()</code>,</p><p><br></p><p><strong>Fetch 22 day returns for all stocks in universe</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"># Get Universe\nuniverse = getuniverse()\n# Fetch prices for last 22 days\nprices = history(universe, \"Close\", :Day, 22)\n</pre><p><br></p><p><strong>Compute log returns (by computing cumulative sum of log difference or log returns)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"># Logic to calculate returns over last month\nlogpricesdiff = diff(log(prices))\nreturnsTA = basecall(logpricesdiff, cumsum)[end]\n</pre><p><br></p><p><strong>Create 2-D array with ticker and stock returns</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"># Create vector with two columns (Name and Returns)&nbsp;\nrets = [colnames(prices) vec(values(returnsTA))]\n</pre><p><br></p><p><strong>Sort returns and select first 5 names</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"># Sorted returns\nsortedrets = sortrows(rets, by=x-&gt;(x[2]))\n# Get 5 names with lowest returns\ntopnames = sortedrets[1:5, 1]\n</pre><p><br></p><p><strong>Create a uniform portfolio (and liquidate stocks not in first 5 names)</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"># Liquidate from portfolio if not in bottom 5 anymore\nfor (stock, positions) in state.account.portfolio.positions\n    if (stock.ticker in topnames)\n        continue\n    else\n        setholdingpct(stock, 0.0)\n    end\nend\n# Create momemtum portfolio\nfor (i,stock) in enumerate(topnames)\n    setholdingpct(stock, 1.0/length(topnames))&nbsp;\nend\n</pre><p><br></p><p><strong>Here is the complete strategy below:</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">##################\n# Basic stock reversal strategy&nbsp;\n# Rebalances portfolio every week&nbsp;\n# Invest in bottom (least performing) 5 stocks of NIFTY based on\n# last 22 days return\n##################\n# Initialize the strategy with various settings and/or parameters\nfunction initialize(state)\n\n  # NIFTY 50 stock universe as of 25/01/2017\n  # This universe has Survivorship bias\n  universe = [\"ACC\",\"ADANIPORTS\",\"AMBUJACEM\",\n  \"ASIANPAINT\",\"AUROPHARMA\",\"AXISBANK\",\"BAJAJ_AUTO\",\n  \"BANKBARODA\",\"BHEL\",\"BPCL\",    \"BHARTIARTL\",\"INFRATEL\",\n  \"BOSCHLTD\",\"CIPLA\",\"COALINDIA\",\"DRREDDY\",\"EICHERMOT\",\n  \"GAIL\",\"GRASIM\",\"HCLTECH\",\"HDFCBANK\",\"HEROMOTOCO\",\"HINDALCO\",\n  \"HINDUNILVR\",\"HDFC\",\"ITC\",\"ICICIBANK\",\"IDEA\",\n  \"INDUSINDBK\",\"INFY\",\"KOTAKBANK\",\"LT\",\"LUPIN\",\"M_M\",\n  \"MARUTI\",\"NTPC\",\"ONGC\",\"POWERGRID\",\"RELIANCE\",\"SBIN\",\n  \"SUNPHARMA\",\"TCS\",\"TATAMTRDVR\",\"TATAMOTORS\",\"TATAPOWER\",\n  \"TATASTEEL\",\"TECHM\",\"ULTRACEMCO\",\"WIPRO\",\"YESBANK\",\"ZEEL\"]\n\n  # Set universe (mandatory before placing any orders)\n  # Dynamic universe is not allowed yet\n  setuniverse(universe)\nend\n\n# Define strategy logic: Calculate 22 days return, sort&nbsp;\n# and invest 20% of wealth in bottom 5 stocks\n\n# All order based functions are called&nbsp;\n# every DAY/WEEK/MONTH (depends on rebalance frequency)\n# Default rebalance Frequency: Daily\nfunction ondata(data, state)\n# Get Universe\nuniverse = getuniverse()\n\n# Fetch prices for last 22 days\nprices = history(universe, \"Close\", :Day, 22)\n\n# Logic to calculate returns over last month\nlogpricesdiff = diff(log(prices))\n\nreturnsTA = basecall(logpricesdiff, cumsum)[end]\n\n\n# Create vector with two columns (Name and Returns)&nbsp;\nrets = [colnames(prices) vec(values(returnsTA))]\n\n# Sorted returns\nsortedrets = sortrows(rets, by=x-&gt;(x[2]))\n\n# Get 5 names with lowest retursn\ntopnames = sortedrets[1:5, 1]\n\n# Liquidate from portfolio if not in bottom 5 anymore\nfor (stock, positions) in state.account.portfolio.positions\n    if (stock.ticker in topnames)\n        continue\n    else\n        setholdingpct(stock, 0.0)\n    end\nend\n\n# Create momemtum portfolio\nfor (i,stock) in enumerate(topnames)\n    setholdingpct(stock, 1.0/length(topnames))&nbsp;\nend\n\n# Track the portfolio value\ntrack(\"Portfolio Value\", state.account.netvalue)\n\n# Output information to console\nLogger.info(\"Portofolio value = $(state.account.netvalue)\")\nend\n</pre><p><br></p></p><blockquote><strong style=\"color: rgb(0, 71, 178);\">This is a sample strategy (only to be used for experiment and research purpose). It does NOT constitute an investment advice.</strong></blockquote><p><br></p>"
		},
		{
			"header":"Tutorial 4: How to use the Utility API to compute metrics?",
			"content":"<p><strong>Utility API</strong>&nbsp;exposes some of the commonly used metrics like price_returns, standard deviation and beta.<strong>&nbsp;</strong>The API is a wrapper around verbose calculations.</p><p><br></p><p>In this tutorial, we will recreate the reversal strategy in&nbsp;<strong>Tutorial #3.</strong></p><p><br></p><p><strong>In the reversal strategy, we created a proxy of poor performance by calculating total returns (log returns) over 22 days.</strong></p><p><br></p><p><strong>Without Utility API</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">universe = getuniverse()\n#Fetch prices for last 22 days\nprices = history(universe, \"Close\", :Day, 22)\n\n#Logic to calculate returns over last month\nlogpricesdiff = diff(log(prices))\n\nreturnsTA = basecall(logpricesdiff, cumsum)[end]\n</pre><p><br></p><p><strong>With Utility API</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">universe = getuniverse()\n#Fetch total returns over last 22 days\nreturnTA = UtilityAPI.price_returns(universe, \"Close\", :Day, window=22, total=true)\n</pre><p>.</p><p>.</p><p>.</p><p><br></p><p><strong>Other useful applications of Utility API</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Also, there are other opions to change the return type (log or simple returns) and duration(daily or total) \n#To get, daily simple returns\nreturnTA = UtilityAPI.price_returns(universe, \"Close\", :Day, window=22, total=false, rettype=:simple)\n</pre><p><br></p><p>In addition to price_returns, it can be used to calculate <strong>standard deviation</strong> and <strong>beta</strong> as well</p><pre class=\"ql-syntax\" spellcheck=\"false\">#Beta of all stocks in universe over a period of 252 days using \n#\"log\" returns of \"Close\" price with \"benchamrk\" as NIFTY 50\nbta = UtilityAPI.beta(universe, :Day, window=252, series=\"Close\", benchmark=\"NIFTY_50\", rettype=:log)\n\n#Standard Deviation of all stocks in universe over a period of 22 days using\n#\"log\" returns\nstd = UtilityAPI.stddev(universe, \"Close\", :Day, window=22, returns=true, rettype=:log)\n\n#For standard deviation of Open PRICES (not returns), set \"returns\" as FALSE\nstd = UtilityAPI.stddev(universe, \"Open\", :Day, window=22, returns=false)\n</pre><p><br></p>"
		},
		{
			"header":"Tutorial 5: How to use the Optimization API for common financial optimization?",
			"content":"<p><strong>Optimization API</strong>&nbsp;exposes some of the commonly used optimization methods used in investment management. The API is a wrapper around verbose functions. It uses Julia&nbsp;<a href=\"http://www.juliaopt.org/JuMP.jl/0.18/\" target=\"_blank\">JuMP</a>&nbsp;library and&nbsp;<a href=\"https://projects.coin-or.org/Ipopt\" target=\"_blank\">Ipopt</a>&nbsp;as an optimization engine.</p><p><br></p><p>In this tutorial, we will detail the available optimization types and various configuration parameters.</p><p><br></p><p>Currently, the optimization API solves for following types of problem</p><ol><li>Minimum absolute deviation</li><li>Minimum semi-absolute deviation</li><li>Mean-Variance</li><li>Minimum volatility</li><li>Minimum Loss</li><li>Minimum Norm</li></ol><p><br></p><p>Optimization API exposes various parameters to configure the optimization type, common financial constraints and user defined restrictions.</p><pre class=\"ql-syntax\" spellcheck=\"false\">#Common API function\n#Parameters are employed as required by the optimization type\n#Default optimization type is minvol \nfunction optimize(symbols,&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method::String=\"minvol\",&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window::Int=22;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targeret::Float64=0.2,\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nfactors::Int=10,\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraints::Constraints=Constraints(),\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialportfolio::Vector{Float64}=Vector{Float64}(),\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linearrestrictions::Vector{LinearRestriction}=LinearRestriction[])\n</pre><p><br></p><p>To employ common financial constraints like exposure, leverage, trade-limit, turnover etc., API exposes the type&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">Constraints</code>. Also, to add linear restrictions, API exposes the type&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">LinearRestrictions</code>. Please visit the API to learn more about the functionality.</p><p><br></p><p>Here we will discuss the a few use cases of the optimization API.</p><p><br></p><p><strong>Minimum Volatility with turnover and position limit</strong></p><p><br></p><p>In minimum volatility, we solve for a portfolio with least standard deviation or variance of portfolio returns. There is no restriction on portfolio return but it can be added via&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">LinearRestriction</code>&nbsp;API. Below we will show a use case which employs both&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">LinearRestriction</code>&nbsp;and&nbsp;<code style=\"background-color: rgb(240, 240, 240);\">Constraints</code>&nbsp;API</p><p><br></p><p>In the following minimum volatility optimization, we impose a restriction on position size such that each position is less than 10% of the total portfolio. In addition, we impose a single period turnover limit of 15%. This minimum volatility optimization employs Factor Analysis to decompose stock returns covariance into low dimensional factor covariance. It is mainly a mathematical technique to simplify the problem. We will discuss Factor Analysis in a some other tutorial.</p><pre class=\"ql-syntax\" spellcheck=\"false\">#Strategy Logic\nfunction ondata(data, state)\n  universe= getuniverse()\n\n  #Compute initial portfolio \n  init_port=ones(length(universe))/length(universe)\n\n  #Get Net Asset Value \n  nav = getportfoliovalue() \n  for (i,position) in getallpositions()\n    init_port[i] = position.lastprice`*`position.quantity/nav\n  end\n\n  #Solve the optimization problem (method = \"minvol\")\n  #Add constraint for turnover (&lt;= 15%)\n  #Add constraint on position limit (Max position size &lt;= 10% of Portfolio)\n  #nfactors is the number of factors to be used from Factor analysis (Num. Factors = 15)\n  (obj, opt_port, status) =&nbsp;OptimizeAPI.optimize(universe,&nbsp;\n                                                    window=66,&nbsp;\n                                                    method=\"minvol\",\n                                                    nfactors=15,\n                                                    constraints=Constraints(maxturnover=0.15, maxpositionlimit=0.1),\n                                                    initialportfolio=init_port)\n\n  if status == :Optimal\n    #Set the target Portfolio as the optimized portfolio\n    settargetportfolio(opt_port)\n  end\n\nend\n</pre><p><br></p><p><strong>Minimum Norm with beta restriction, leverage restrictions and target portfolio return</strong></p><p><br></p><p>In minimum norm, we solve for least euclidean distance of target portfolio from initial portfolio subject to certain restrictions.</p><p><br></p><p>In the following minimum norm optimization, we impose a restriction portfolio beta such that portfolio beta is between 0.95 and 1.0. In addition, we impose a portfolio leverage condition such that portfolio leverage is between 0.95 and 1.05.  This minimum volatility optimization employs Factor Analysis to decompose stock returns covariance into low dimensional factor covariance. It is mainly a mathematical technique to simplify the problem. We will detail Factor Analysis in a some other tutorial.</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">#Strategy Logic\nfunction ondata(data, state)\n  universe= getuniverse()\n\n  #Compute initial portfolio \n  init_port=ones(length(universe))/length(universe)\n\n  #Get Net Asset Value \n  nav = getportfoliovalue() \n  for (i,position) in getallpositions()\n    init_port[i] = position.lastprice * position.quantity/nav\n  end\n  \n  #Compute stock beta using UtilityAPI  \n  bta = UtilityAPI.beta(universe, :Day, window=252)\n  #Reshapae beta to 1-d array\n  bta_arr = reshape(values(bta), (length(universe),))\n  \n  #66-day Historical returns (as proxy for forward returns)\n  price_ret = UtilityAPI.price_returns(universe, \"Close\", :Day, window=66, total=true)\n  ret_arr = reshape(values(price_ret), (length(universe),))\n \n  #Solve the optimization problem (method = \"minvol\")\n  #Add constraint on Portfolio Leverage (0.95 &lt;= Portfolio Leverage &lt;= 1.05) \n  #Add constraint on Portfolio Beta (0.95 &lt;= Portfolio Beta &lt;= 1.0)\n  #Add constraint on Portfolio Returns (Portfolio Returns &gt;= 0.05)\n\n  l_restrictions = [LinearRestriction(bta_arr, 0.95, 1.0), LinearRestriction(ret_arr, 0.05, Inf)]\n\n  (obj, opt_port, status) =&nbsp;OptimizeAPI.optimize(universe,&nbsp;\n                                                    method=\"minnorm\",\n                                                    constraints=Constraints(minleverage=0.95, maxleverage=1.05),\n                                                    initialportfolio=init_port,\n                                                    linearrestrictions=l_restrictions)\n\n  if status == :Optimal\n    setttargetportfolio(opt_port)\n  end\n  \nend\n</pre><p><br></p><blockquote><strong style=\"color: rgb(0, 71, 178);\"><em>Optimization API is in beta and still evolving. Please report any issues on the community.</em></strong></blockquote><p><br></p>"
		},
		{
			"header":"Tutorial 6: Create a mean-variance portfolio using Optimization API",
			"content": "<p><strong><em>\"What is a 'Mean-Variance Analysis'</em></strong></p><p><em>A mean-variance analysis is the process of weighing risk (variance) against expected return. By looking at the expected return and variance of an asset, investors attempt to make more efficient investment choices – seeking the lowest variance for a given expected return or seeking the highest expected return for a given variance level.\"&nbsp;</em>- Investopedia</p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\">In Mean-Variance Optimization means, we try to create portfolio that have the maximum&nbsp;</span><strong style=\"color: rgb(51, 51, 51);\">mean</strong><span style=\"color: rgb(51, 51, 51);\">&nbsp;(expected return) for a given&nbsp;</span><strong style=\"color: rgb(51, 51, 51);\">variance</strong><span style=\"color: rgb(51, 51, 51);\">&nbsp;of return (or standard deviation of returns) or the minimum variance of return for a given mean (expected return).</span></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\">Mathematically, this problem can be represented as a</span></p><p><span style=\"background-color: transparent;\"><img src=\"https://lh3.googleusercontent.com/D0_Ppfh-TSpYKvc80-q7Z1waehoRBUuYhwzPQkejQpXdezBZUNjYH1rjrTuJwbCpqx-0WcjUbvZdYKQ8nGItFqZsMDWn9OPE3zSY3VwQLF-uKyYZMokzXTCKLooTAa6pN3Tp8Ter\" alt=\"Screen Shot 2017-11-14 at 6.48.29 PM.png\" height=\"145\" width=\"544\"></span></p><p><span style=\"background-color: transparent;\">where</span></p><p><br></p><ul><li><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/88b1e0c8e1be5ebe69d18a8010676fa42d7961e6\" alt=\"w\">&nbsp;is a vector of portfolio weights</li><li><span style=\"background-color: transparent;\">Ω&nbsp;</span>is the&nbsp;covariance matrix&nbsp;for the returns on the assets in the portfolio</li><li>R is a vector of expected returns.</li><li><span style=\"background-color: transparent;\">w'Ωw&nbsp;</span>is the variance of portfolio return.</li><li>R'w is the expected return on the portfolio.</li><li><span style=\"background-color: transparent;\">μ&nbsp;</span>is the target return of the portfolio</li></ul><p><br></p><p>On the platform, we have created an optimization API (<strong><em>OptimizeAPI&nbsp;</em></strong>) that solves this problem and few variants of the same problem.</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">function ondata(data, state)\n  universe = getuniverse()\n  #Use optimization API to solve mean-variance problem (method = meanvar)\n  #More parameters include constraints, initialportfolio and linearrestrictions [Tutorial #5]\n  #Output: Tuple of objective value, optimal portfolio and status of optimization\n  (obj, optimal_portfolio, status) = OptimizeAPI.optimize(universe,&nbsp;window=66,&nbsp;method=\"meanvar\", targetret=0.2)\n  \n  if(status == :Optimal)\n    #Rebalance the portfolio with settargetportfolio (Uses setholdingpct internally)\n    settargetportfolio(optimal_portfolio)\n  end\nend\n</pre><p><br></p><p><span style=\"color: rgb(51, 51, 51);\">In other variant of Mean-Variance Optimization, we try to create portfolio by solving the following:</span></p><p><br></p><p><span style=\"background-color: transparent;\"><img src=\"https://lh3.googleusercontent.com/-o7mezj8l-ZdDHzsQdaWa3iJs_lhNzzVkJkTezS6IPjedWEZExqtgUEx7yrvl51Es7tWz6-evpaHTA9Xer8S1T-uMk-gOsbGX6asKPZt9ox81R8RKngCuq620aKXYagRH-swIRsV\" alt=\"Screen Shot 2017-11-14 at 7.24.11 PM.png\" height=\"138\" width=\"470\"></span></p><p><span style=\"background-color: transparent;\">where</span></p><p><br></p><ul><li><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/88b1e0c8e1be5ebe69d18a8010676fa42d7961e6\" alt=\"w\">&nbsp;is a vector of portfolio weights</li><li><span style=\"background-color: transparent;\">Ω&nbsp;</span>is the&nbsp;covariance matrix&nbsp;for the returns on the assets in the portfolio</li><li>R is a vector of expected returns.</li><li><span style=\"background-color: transparent;\">w'Ωw&nbsp;</span>is the variance of portfolio return.</li><li>R'w is the expected return on the portfolio.</li><li><span style=\"background-color: transparent;\">λ&nbsp;</span>is risk aversion parameter</li></ul><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">function ondata(data, state)\n  universe = getuniverse()\n  #Use optimization API to solve mean-variance problem (method = \"meanvar2\")\n  #Output: Tuple of objective value, optimal portfolio and status of optimization\n  (obj, opt_port, status) = OptimizeAPI.optimize(universe,&nbsp;window=66,&nbsp;method=\"meanvar2\", targetret=0.2, lamda=1.0)\n\n  if(status == :Optimal)\n    #Rebalance the portfolio with settargetportfolio (Uses setholdingpct internally) \n    settargetportfolio(opt_port)\n  end\nend\n</pre><p><br></p><blockquote><strong style=\"color: rgb(0, 71, 178);\">This is a sample strategy (only for experiment and research purpose) and DOES NOT constitute an investment advice</strong></blockquote><p><br></p>"
		}
	]
}